"use strict";(self.webpackChunkkratix_docs=self.webpackChunkkratix_docs||[]).push([[8771],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>h});var r=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,r,i=function(e,t){if(null==e)return{};var n,r,i={},a=Object.keys(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var s=r.createContext({}),c=function(e){var t=r.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},p=function(e){var t=c(e.components);return r.createElement(s.Provider,{value:t},e.children)},u="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},m=r.forwardRef((function(e,t){var n=e.components,i=e.mdxType,a=e.originalType,s=e.parentName,p=l(e,["components","mdxType","originalType","parentName"]),u=c(n),m=i,h=u["".concat(s,".").concat(m)]||u[m]||d[m]||a;return n?r.createElement(h,o(o({ref:t},p),{},{components:n})):r.createElement(h,o({ref:t},p))}));function h(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var a=n.length,o=new Array(a);o[0]=m;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l[u]="string"==typeof e?e:i,o[1]=l;for(var c=2;c<a;c++)o[c]=n[c];return r.createElement.apply(null,o)}return r.createElement.apply(null,n)}m.displayName="MDXCreateElement"},2270:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>o,default:()=>u,frontMatter:()=>a,metadata:()=>l,toc:()=>c});var r=n(7462),i=(n(7294),n(3905));const a={description:"Documentation for writing Promise Pipelines, covering how Kratix internally execute the Pipeline containers",title:"Promise Pipelines",sidebar_label:"Pipelines"},o="Resource Request Pipelines",l={unversionedId:"main/reference/resource-requests/pipelines",id:"main/reference/resource-requests/pipelines",title:"Promise Pipelines",description:"Documentation for writing Promise Pipelines, covering how Kratix internally execute the Pipeline containers",source:"@site/docs/main/05-reference/05-resource-requests/02-pipelines.md",sourceDirName:"main/05-reference/05-resource-requests",slug:"/main/reference/resource-requests/pipelines",permalink:"/docs/main/reference/resource-requests/pipelines",draft:!1,editUrl:"https://github.com/syntasso/kratix-docs/tree/main/docs/main/05-reference/05-resource-requests/02-pipelines.md",tags:[],version:"current",sidebarPosition:2,frontMatter:{description:"Documentation for writing Promise Pipelines, covering how Kratix internally execute the Pipeline containers",title:"Promise Pipelines",sidebar_label:"Pipelines"},sidebar:"mainSidebar",previous:{title:"Introduction",permalink:"/docs/main/reference/resource-requests/intro"},next:{title:"Deleting",permalink:"/docs/main/reference/resource-requests/deleting-a-resource-request"}},s={},c=[{value:"Pipeline Volumes",id:"pipeline-volumes",level:2},{value:"<code>/input</code>",id:"input",level:3},{value:"<code>/output</code>",id:"output",level:3},{value:"Intermediary containers",id:"intermediary-containers",level:4},{value:"Final container",id:"final-container",level:4},{value:"<code>/metadata</code>",id:"metadata",level:3},{value:"Pipeline runs",id:"pipeline-runs",level:2},{value:"Passing secrets to the Pipeline",id:"passing-secrets-to-the-pipeline",level:2}],p={toc:c};function u(e){let{components:t,...n}=e;return(0,i.kt)("wrapper",(0,r.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"resource-request-pipelines"},"Resource Request Pipelines"),(0,i.kt)("p",null,"A ",(0,i.kt)("a",{parentName:"p",href:"../promises/intro"},"Kratix Promise")," is configured with a Request Pipeline,\ndefined as ",(0,i.kt)("inlineCode",{parentName:"p"},"xaasRequestPipeline")," in the Promise definition. This pipeline is an\nordered list of OCI-compliant images. Each image runs as an init container\nwithin a single Kubernetes pod. "),(0,i.kt)("h2",{id:"pipeline-volumes"},"Pipeline Volumes"),(0,i.kt)("p",null,"Each container is given access to three directories:"),(0,i.kt)("h3",{id:"input"},(0,i.kt)("inlineCode",{parentName:"h3"},"/input")),(0,i.kt)("p",null,"This directory is pre-populated with files that are provided by Kratix or the\nprevious pipeline container. The first container will have access to an\n",(0,i.kt)("inlineCode",{parentName:"p"},"object.yaml")," file containing the Resource Request submitted to the platform.\nThe ",(0,i.kt)("inlineCode",{parentName:"p"},"/input")," directory in subsequent containers contain content from the previous\ncontainer's ",(0,i.kt)("inlineCode",{parentName:"p"},"/output")," directory."),(0,i.kt)("h3",{id:"output"},(0,i.kt)("inlineCode",{parentName:"h3"},"/output")),(0,i.kt)("p",null,"This directory is an empty directory provided to the container for writing files\nfor future use."),(0,i.kt)("p",null,"Containers must ensure that the files required in future containers or that need\nto be scheduled are written to this directory at the end of the container's\nexecution. In general, containers should copy all files from ",(0,i.kt)("inlineCode",{parentName:"p"},"/input")," to\n",(0,i.kt)("inlineCode",{parentName:"p"},"/output")," unless the container knows the file is no longer required."),(0,i.kt)("h4",{id:"intermediary-containers"},"Intermediary containers"),(0,i.kt)("p",null,"If the container is not the last container in the pipeline its ",(0,i.kt)("inlineCode",{parentName:"p"},"/output"),"\ndirectory will become the next container's ",(0,i.kt)("inlineCode",{parentName:"p"},"/input")," directory."),(0,i.kt)("h4",{id:"final-container"},"Final container"),(0,i.kt)("p",null,"All files present in ",(0,i.kt)("inlineCode",{parentName:"p"},"/output")," directory of the final container will be written\nto your GitOps repository."),(0,i.kt)("admonition",{type:"note"},(0,i.kt)("p",{parentName:"admonition"},"At this time, all files must be written to the root directory of ",(0,i.kt)("inlineCode",{parentName:"p"},"/output")," (i.e.\nthere should not be any subdirectories within ",(0,i.kt)("inlineCode",{parentName:"p"},"/output"),"), and every file must\ncontain only valid Kubernetes documents that can be applied to a cluster. Each\ndocument will be scheduled per the ",(0,i.kt)("a",{parentName:"p",href:"../multicluster-management"},"scheduling docs"),".")),(0,i.kt)("h3",{id:"metadata"},(0,i.kt)("inlineCode",{parentName:"h3"},"/metadata")),(0,i.kt)("p",null,"All containers in the pipeline have access to this directory."),(0,i.kt)("p",null,"Pipeline containers can control aspects of how Kratix behaves by creating special files in this\ndirectory:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"cluster-selectors.yaml")," can be added to any Promise to\nfurther refine where the resources in ",(0,i.kt)("inlineCode",{parentName:"li"},"/output")," will be\n",(0,i.kt)("a",{parentName:"li",href:"/docs/main/reference/multicluster-management#pipeline"},"scheduled"),"."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"status.yaml")," allows the pipeline to communicate information about the\nResource Request back to the requester. See ",(0,i.kt)("a",{parentName:"li",href:"/docs/main/reference/resource-requests/status"},"status documentation\nfor more information"),".")),(0,i.kt)("br",null),(0,i.kt)("p",null,"Kratix scans for these files and ignores all other files in the ",(0,i.kt)("inlineCode",{parentName:"p"},"/metadata"),"\ndirectory."),(0,i.kt)("h2",{id:"pipeline-runs"},"Pipeline runs"),(0,i.kt)("p",null,"A pipeline is run on each Resource Request reconciliation loop. Kubernetes\nreconciles on a number of different actions including, but not limited to:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Regular interval (default: 10 hours, not currently configurable)"),(0,i.kt)("li",{parentName:"ul"},"Recreating or restarting the Kratix Controller"),(0,i.kt)("li",{parentName:"ul"},"A change to the Resource Request (not yet supported)")),(0,i.kt)("br",null),"All pipelines should be idempotent as there is a guarantee that they will be run multiple times a day, and may be run much more frequently depending on other environmental impacts like pod restarts.",(0,i.kt)("h2",{id:"passing-secrets-to-the-pipeline"},"Passing secrets to the Pipeline"),(0,i.kt)("admonition",{title:"Under Development",type:"caution"},(0,i.kt)("p",{parentName:"admonition"},"We're currently working on providing alternative ways to read secrets from both self hosted and SaaS providers. If you'd like early access, reach out.")),(0,i.kt)("p",null,"To allow the pipeline to access in-cluster secrets, target the Platform Cluster and do the following:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"Create the Secret you'd like to access. For example:",(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"kubectl create secret generic promise-secret \\\n    --from-literal=apikey=topsecret\n"))),(0,i.kt)("li",{parentName:"ol"},"Create a ClusterRole giving ",(0,i.kt)("inlineCode",{parentName:"li"},"get")," permissions to the ",(0,i.kt)("inlineCode",{parentName:"li"},"promise-secret")," created above:",(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"kubectl create clusterrole promise-secret-cr \\\n    --verb=get \\\n    --resource=secrets \\\n    --resource-name=promise-secret\n"))),(0,i.kt)("li",{parentName:"ol"},"Create a ClusterRoleBinding to associate the pipeline ServiceAccount\n(created by Kratix, on Promise install) with the ClusterRole. Reference\nthe ClusterRole created above:",(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"# Replace PROMISE with the name of your promise\nkubectl create clusterrolebinding promise-secret \\\n    --clusterrole=promise-secret-cr \\\n    --serviceaccount=default:PROMISE-default-pipeline-secret \\\n"))),(0,i.kt)("li",{parentName:"ol"},"Access the Base64 enconded Secret in the pipeline with the ",(0,i.kt)("inlineCode",{parentName:"li"},"kubectl")," CLI",(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre"},"kubectl get secret promise-secret -o=jsonpath='{.data.apikey}'\n")))),(0,i.kt)("p",null,"For a working example, check the ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/syntasso/kratix-marketplace/tree/main/slack"},"Slack Promise")," available in the Marketplace."))}u.isMDXComponent=!0}}]);